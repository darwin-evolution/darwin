Darwin
-------
image:https://travis-ci.org/darwin-evolution/darwin.svg[alt="Travis"]
image:https://img.shields.io/badge/license-MIT-brightgreen.svg[alt="MIT License"]

== Why?
Darwin was creataed to ease refactoring. He allows You to test Your new
implementation, in any environment, even in production. Darwin basically
executes existing and new implementations comparing results, and logging
the outcome. He allows you to choose which outcome to return, the 'evolved'
or it's 'protoplast'.

== How?

=== Coding

Darwin has very little dependencies:

* http://www.slf4j.org/[slf4j]
* https://github.com/typesafehub/config[typesafe-config]
* http://metrics.dropwizard.io/3.1.0/[dropwizard-metrics]

that's all he needs to help Your code Evolve!

=== Evolving

Basic idea in darwin is evolution, it is transition from 'protoplast' to 'evolved'
implementation. This process is monitored and logged, increasing safety
of your refactorings, and providing an easy way to test backward compatibility.


==== So evolve!

Given two implementations: calculateMax and calculateMaxWithMath
we can write a simple evolution:


[source,java]
----
        final Integer a = 1, b = 3, c = -1; // <1>

        Integer max = Evolution.<Integer>of("calculateMax") // <2>
                .from(new ProtoplastExecutionHarness<Integer>() { // <3>
                    @Override
                    public Integer execute() throws Exception {
                        arguments(a, b, c); // <4>
                        return calculateMax(a, b, c); // <5>
                    }
                })
                .to(new EvolvedExecutionHarness<Integer>() { // <6>
                    @Override
                    public Integer execute() throws Exception {
                        arguments(a, b, c); // <7>
                        return calculateMax2(a, b, c); // <8>
                    }
                })
                .evolve(); // <9>
----
<1> Define arguments
<2> Create Evolution named "calculateMax"
<3> Create Protoplast execution harness - it will hold our old implementation
<4> We log protoplast arguments
<5> We execute protoplast implementation
<6> Create Evolved executution harness - it will hold our new implementation
<7> We log evolved arguments
<8> we execute evolved implementation
<9> And we return configured result either (protoplast or evolved)

Such configuration will result in slf4j log message in category **darwin.evolution** :

[source,csv]
----
       "calculateMax"|"PROTOPLAST"|"1463682597919"|"OK"||"249896"||||"171597"|||
----


==== Choosing implementation

Darwin works out of the box, by logging via slf4j and using Typesafe Config
to choose which implementation's execution result should be returned to caller.

[source,java]
----
        public abstract class ImplementationChooser {

            public abstract ImplementationPreference chooseImplementation(String evolutionName);
        ...

        }
----


Decision is made using implemntation of ImplementationChooser.chooseImplementation.
Default implementation comes from TypesafeConfigImplementationChooser. You can configure
your implementation chooser by supplying your own implementation of ImplementationChooser,
or you can configure default chooser with config.

Default chooser looks for configuration variable according to scheme:

[source,java]
----
       darwin.evolution.calculateMax.evolved = true
----

=== Maven

Base dependency:

[source,xml]
----
<dependency>
    <groupId>com.github.darwin-evolution</groupId>
    <artifactId>darwin</artifactId>
    <version>0.9.1</version>
</dependency>
----

=== Logging in JSON format

To log evolution information, ComparisonResult to be precise in JSON format
we need to add extra dependency:


[source,xml]
----
<dependency>
    <groupId>com.github.darwin-evolution</groupId>
    <artifactId>darwin-jackson</artifactId>
    <version>0.9.1</version>
</dependency>
----

We're using jackson because it is most popular JSON serializer for JavaEE projects.
