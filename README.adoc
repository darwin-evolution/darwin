__Darwin
-------
image:https://travis-ci.org/darwin-evolution/darwin.svg[alt="Travis"]
image:https://img.shields.io/badge/license-MIT-brightgreen.svg[alt="MIT License"]

== Why?
Darwin was creataed to ease refactoring. He allows You to test Your new
implementation, in any environment, even in production. Darwin basically
executes existing and new implementations comparing results, and logging
the outcome. He allows you to choose which outcome to return, the 'evolved'
or it's 'protoplast'.

== How?

=== Coding

Darwin has very little dependencies:

* http://www.slf4j.org/[slf4j]
* https://github.com/typesafehub/config[typesafe-config]
* http://metrics.dropwizard.io/3.1.0/[dropwizard-metrics]

that's all he needs to help Your code Evolve!

=== Evolving

Basic idea in darwin is evolution, it is transition from **'protoplast'** to **'evolved'**
implementation. This process is monitored and logged, increasing safety
of your refactorings, and providing an easy way to test backward compatibility.


==== So evolve!

Given two implementations: calculateMax and calculateMaxWithMath
we can write a simple evolution:


[source,java]
----
        final Integer a = 1, b = 3, c = -1; // <1>

        Integer max = Evolution.<Integer>of("calculateMax") // <2>
                .from(new ProtoplastExecutionHarness<Integer>() { // <3>
                    @Override
                    public Integer execute() throws Exception {
                        arguments(a, b, c); // <4>
                        return calculateMax(a, b, c); // <5>
                    }
                })
                .to(new EvolvedExecutionHarness<Integer>() { // <6>
                    @Override
                    public Integer execute() throws Exception {
                        arguments(a, b, c); // <7>
                        return calculateMax2(a, b, c); // <8>
                    }
                })
                .evolve(); // <9>
----
<1> Define arguments
<2> Create Evolution named "calculateMax"
<3> Create Protoplast execution harness - it will hold our old implementation
<4> We log protoplast arguments
<5> We execute protoplast implementation
<6> Create Evolved executution harness - it will hold our new implementation
<7> We log evolved arguments
<8> we execute evolved implementation
<9> And we return configured result either (protoplast or evolved)

Such configuration will result in slf4j log message in category **darwin.evolution** :

[source,csv]
----
       "calculateMax"|"PROTOPLAST"|"1463682597919"|"OK"||"249896"||||"171597"|||
----


==== Choosing implementation

Darwin works out of the box by returning **'protoplast'** implementation's result.
To choose which implementation's result should be returned to caller, Darwin uses
ImplementationChooser. By default it uses Typesafe Config, to lookup which
implementation is preferred.


[source,java]
----
        public abstract class ImplementationChooser {

            public abstract ImplementationPreference chooseImplementation(String evolutionName);
        ...

        }
----


Decision is made using implemntation of ImplementationChooser.chooseImplementation.
Default implementation comes from TypesafeConfigImplementationChooser. You can configure
your implementation chooser by supplying your own implementation of ImplementationChooser,
or you can configure default chooser with config.

Default chooser looks for configuration variable according to scheme:

[source,java]
----
       darwin.evolution.calculateMax.evolved = true
----

Simplest way to provide it, is via system properties:
[source,java]
----
    -Ddarwin.evolution.calculateMax.evolved=true
----

or if you want to unleash full power of typesafe config go visit https://github.com/typesafehub/config[it's homepage.]

=== Maven

Base dependency:

[source,xml]
----
<dependency>
    <groupId>com.github.darwin-evolution</groupId>
    <artifactId>darwin</artifactId>
    <version>0.9.1</version>
</dependency>
----

=== Logging in JSON format

To log evolution information in JSON format we need to add extra dependency:


[source,xml]
----
<dependency>
    <groupId>com.github.darwin-evolution</groupId>
    <artifactId>darwin-jackson</artifactId>
    <version>0.9.1</version>
</dependency>
----

We're using jackson because it is most popular JSON serializer for JavaEE projects.
Sample json output, that will be logged to slf4j (TRACE, darwin.evolution):

[source,json]
----
{
	"name": "testEvolution",
	"implementationPreference": "EVOLVED",
	"timestamp": 1465313830367,
	"resultType": "OK",
	"protoplastDurationNs": 100,
	"protoplastArguments": [1, 2],
	"protoplastValue": "6",
	"protplastException": null,
	"evolvedDurationNs": 130,
	"evolvedArguments": [1, 2],
	"evolvedValue": "6",
	"evolvedException": null
}
----

=== Default result logging

By default, results are logged in psv (pipe separated values) format, to slf4j.
It logs in **TRACE** treshold under category: **darwin.evolution**
